source("D:/Fly_survival_app/flySurvivalApp/R/avi_ui.R")
tools::showNonASCIIfile("R/browse_ui.R")
source("D:/Fly_survival_app/flySurvivalApp/R/avi_ui.R")
tools::showNonASCIIfile("R/avi_ui.R")
tools::showNonASCIIfile("R/avi_converter.R")
library(devtools)
load_all()
load_all()
Load_fly_app()
load_all()
Load_fly_app()
Load_fly_app()
load_all()
document()
load_all()
document()
Load_fly_app()
load_all()
Load_fly_app()
document()
Load_fly_app()
Load_fly_app()
Load_fly_app()
load_all()
Load_fly_app()
document()
Load_fly_app()
document()
document()
document()
load_all()
Load_fly_app()
load_all()
Load_fly_app()
load_all()
Load_fly_app()
load_all()
Load_fly_app()
for (folder in folders) {
if (!dir.exists(folder)) {
dir.create(folder)
message(paste("Created folder:", folder))
} else {
message(paste("Folder already exists:", folder))
}
}
usethis::use_testthat()
usethis::use_test()
usethis::use_test("app.R")
usethis::use_test(list.files(R))
usethis::use_test(list.files("R"))
list.files("R")
lapply(list.files("R"), usethis::use_test)
# Use a temporary directory to avoid messing with real folders
tmp <- local_tempdir()
library(testthat)
library(shiny)
library(withr)
# Use a temporary directory to avoid messing with real folders
tmp <- local_tempdir()
old_wd <- setwd(tmp)
on.exit(setwd(old_wd), add = TRUE)
# Call Load_fly_app but don't run the shiny app
# We'll modify the function slightly to allow returning the UI/server without launching
app <- Load_fly_app()
# Call Load_fly_app but don't run the shiny app
# We'll modify the function slightly to allow returning the UI/server without launching
app <- Load_fly_app()
load_all
load_all()
load_all()
getwd()
setwd("D:/Fly_survival_app")
getwd()
load_all()
setwd("D:/Fly_survival_app/flySurvivalApp/")
getwd()
load_all()
load_all()
#
#   # Call Load_fly_app but don't run the shiny app
#   # We'll modify the function slightly to allow returning the UI/server without launching
#   app <- Load_fly_app()
#
#   # Check if folders were created
#   expect_true(dir.exists(file.path(tmp, "statsdir")))
#   expect_true(dir.exists(file.path(tmp, "avi_frames")))
# })
#
test_that("Load_fly_app returns a Shiny app object", {
app <- Load_fly_app()
expect_s3_class(app, "shiny.appobj")
expect_true(all(c("ui", "server") %in% names(app)))
})
app <- Load_fly_app()
class(app)
expect_s3_class(app, "shiny.appobj")
#
#   # Call Load_fly_app but don't run the shiny app
#   # We'll modify the function slightly to allow returning the UI/server without launching
#   app <- Load_fly_app()
#
#   # Check if folders were created
#   expect_true(dir.exists(file.path(tmp, "statsdir")))
#   expect_true(dir.exists(file.path(tmp, "avi_frames")))
# })
#
test_that("Load_fly_app returns a Shiny app object", {
app <- Load_fly_app()
expect_s3_class(app, "shiny.appobj")
})
app
# Assuming modules are loaded correctly
avi <- avi_to_tiff_panel()
expect_true(all(c("ui", "server") %in% names(avi)))
inference <- inference_panel()
expect_true(all(c("ui", "server") %in% names(inference)))
test_that("Modules have ui and server functions", {
# Assuming modules are loaded correctly
avi <- avi_to_tiff_panel()
expect_true(all(c("ui", "server") %in% names(avi)))
inference <- inference_panel()
expect_true(all(c("ui", "server") %in% names(inference)))
})
test_that("Avi_to_tiff handles empty folder gracefully", {
tmp <- local_tempdir()
log_messages <- character()
log_fun <- function(msg) log_messages <<- c(log_messages, msg)
# Should not error and should log "No AVI files found"
expect_silent(Avi_to_tiff(tmp, log_fun = log_fun))
expect_true(any(grepl("No AVI files found", log_messages)))
})
test_that("Avi_to_tiff creates output folders", {
tmp <- local_tempdir()
# Create fake AVI file
avi_file <- file.path(tmp, "test_video.AVI")
file.create(avi_file)
# Mock ffmpeg call to avoid actually running conversion
mock_system2 <- function(command, args, ...) 0  # pretend conversion always succeeds
withr::local_mock(system2 = mock_system2, .env = "base")
log_messages <- character()
log_fun <- function(msg) log_messages <<- c(log_messages, msg)
Avi_to_tiff(tmp, log_fun = log_fun)
# Check that output folder was created
expected_folder <- file.path("avi_frames", "test_video_frames")
expect_true(dir.exists(expected_folder))
# Check that log messages include success message
expect_true(any(grepl("Finished converting: test_video.AVI", log_messages)))
})
test_that("Avi_to_tiff stops if ffmpeg missing", {
tmp <- local_tempdir()
# Temporarily override get_ffmpeg_path to point to a non-existent file
withr::local_mock(get_ffmpeg_path = function() "nonexistent_ffmpeg", .env = environment(Avi_to_tiff))
expect_error(Avi_to_tiff(tmp), "FFmpeg not found")
})
test_that("Avi_to_tiff handles empty folder gracefully", {
tmp <- local_tempdir()
log_messages <- character()
log_fun <- function(msg) log_messages <<- c(log_messages, msg)
# Should not error and should log "No AVI files found"
expect_silent(Avi_to_tiff(tmp, log_fun = log_fun))
expect_true(any(grepl("No AVI files found", log_messages)))
})
test_that("Avi_to_tiff creates output folders", {
tmp <- local_tempdir()
# Create fake AVI file
avi_file <- file.path(tmp, "test_video.AVI")
file.create(avi_file)
# Mock ffmpeg call to avoid actually running conversion
mock_system2 <- function(command, args, ...) 0  # pretend conversion always succeeds
withr::local_mock(system2 = mock_system2, .env = "base")
log_messages <- character()
log_fun <- function(msg) log_messages <<- c(log_messages, msg)
Avi_to_tiff(tmp, log_fun = log_fun)
# Check that output folder was created
expected_folder <- file.path("avi_frames", "test_video_frames")
expect_true(dir.exists(expected_folder))
# Check that log messages include success message
expect_true(any(grepl("Finished converting: test_video.AVI", log_messages)))
})
test_that("Avi_to_tiff finds ffmpeg path on Windows", {
# Mock Sys.info() to return Windows
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Windows"))
# Call Avi_to_tiff internals via a wrapper
ffmpeg_path <- local({
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
if (sysname == "Windows") {
return(file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
} else if (sysname == "Darwin") {
return(file.path("ffmpeg_mac", "ffmpeg"))
} else {
stop("Unsupported OS for bundled ffmpeg")
}
}
get_ffmpeg_path()
})
expect_equal(ffmpeg_path, file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
})
library(mockery)
install.packages("mockery")
# Mock Sys.info() to return Windows
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Windows"))
library(mockery)
# Mock Sys.info() to return Windows
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Windows"))
test_that("Avi_to_tiff finds ffmpeg path on Windows", {
# Mock Sys.info() to return Windows
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Windows"))
# Call Avi_to_tiff internals via a wrapper
ffmpeg_path <- local({
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
if (sysname == "Windows") {
return(file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
} else if (sysname == "Darwin") {
return(file.path("ffmpeg_mac", "ffmpeg"))
} else {
stop("Unsupported OS for bundled ffmpeg")
}
}
get_ffmpeg_path()
})
expect_equal(ffmpeg_path, file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
})
test_that("Avi_to_tiff finds ffmpeg path on macOS", {
# Mock Sys.info() to return Darwin
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Darwin"))
ffmpeg_path <- local({
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
if (sysname == "Windows") {
return(file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
} else if (sysname == "Darwin") {
return(file.path("ffmpeg_mac", "ffmpeg"))
} else {
stop("Unsupported OS for bundled ffmpeg")
}
}
get_ffmpeg_path()
})
expect_equal(ffmpeg_path, file.path("ffmpeg_mac", "ffmpeg"))
})
# Mock Sys.info() to return Darwin
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Darwin"))
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
if (sysname == "Windows") {
return(file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
} else if (sysname == "Darwin") {
return(file.path("ffmpeg_mac", "ffmpeg"))
} else {
stop("Unsupported OS for bundled ffmpeg")
}
}
get_ffmpeg_path()
test_that("Avi_to_tiff stops for unsupported OS", {
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Linux"))
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
if (sysname == "Windows") {
return(file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
} else if (sysname == "Darwin") {
return(file.path("ffmpeg_mac", "ffmpeg"))
} else {
stop("Unsupported OS for bundled ffmpeg")
}
}
expect_error(get_ffmpeg_path(), "Unsupported OS")
})
test_that("Avi_to_tiff handles empty folder gracefully", {
tmp <- local_tempdir()
log_messages <- character()
log_fun <- function(msg) log_messages <<- c(log_messages, msg)
# Should not error and should log "No AVI files found"
expect_silent(Avi_to_tiff(tmp, log_fun = log_fun))
expect_true(any(grepl("No AVI files found", log_messages)))
})
test_that("Avi_to_tiff handles empty folder gracefully", {
tmp <- local_tempdir()
log_messages <- character()
log_fun <- function(msg) log_messages <<- c(log_messages, msg)
# Should not error and should log "No AVI files found"
expect_silent(Avi_to_tiff(tmp, log_fun = log_fun))
expect_true(any(grepl("No AVI files found", log_messages)))
})
load_all()
Load_fly_app()
install.packages("flySurvivalApp")
install.packages("flySurvivalApp_0.0.0.9000.tar.gz", repos = NULL, type = "source")
library(flySurvivalApp)
Load_fly_app()
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
# --- Check bundled paths (if you ship your own ffmpeg) ---
if (sysname == "Windows") {
candidate <- file.path("ffmpeg_windows", "bin", "ffmpeg.exe")
} else if (sysname == "Darwin") {
candidate <- file.path("ffmpeg_mac", "ffmpeg")
} else {
candidate <- NULL
}
if (!is.null(candidate) && file.exists(candidate)) {
return(normalizePath(candidate))
}
# --- Check system ffmpeg ---
sys_ffmpeg <- Sys.which("ffmpeg")
if (nzchar(sys_ffmpeg)) {
return(normalizePath(sys_ffmpeg))
}
# --- Install via Python managed environment ---
message("FFmpeg not found. Using managed Python environment...")
# Force managed Python
Sys.setenv(RETICULATE_PYTHON = "managed")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
ffmpeg <- import("imageio_ffmpeg")
exe <- ffmpeg$get_ffmpeg_exe()
return(normalizePath(exe))
}
# --- Example usage ---
ffmpeg_path <- get_ffmpeg_path()
ffmpeg_path
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
# --- Check bundled paths (if you ship your own ffmpeg) ---
if (sysname == "Windows") {
candidate <- file.path("ffmpeg_windows", "bin", "ffmpeg.exe")
} else if (sysname == "Darwin") {
candidate <- file.path("ffmpeg_mac", "ffmpeg")
} else {
candidate <- NULL
}
if (!is.null(candidate) && file.exists(candidate)) {
return(normalizePath(candidate))
}
# --- Check system ffmpeg ---
sys_ffmpeg <- Sys.which("ffmpeg")
if (nzchar(sys_ffmpeg)) {
return(normalizePath(sys_ffmpeg))
}
# --- Install via Python managed environment ---
message("FFmpeg not found. Using managed Python environment...")
# Force managed Python
Sys.setenv(RETICULATE_PYTHON = "managed")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
ffmpeg <- import("imageio_ffmpeg")
exe <- ffmpeg$get_ffmpeg_exe()
return(normalizePath(exe))
}
# --- Example usage ---
ffmpeg_path <- get_ffmpeg_path()
# Force managed Python
Sys.setenv(RETICULATE_PYTHON = "managed")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
ffmpeg <- import("imageio_ffmpeg")
# Force managed Python
Sys.setenv(RETICULATE_PYTHON = "managed")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
ffmpeg <- import("imageio_ffmpeg")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
library(reticulate)
# --- Install via Python managed environment ---
message("FFmpeg not found. Using managed Python environment...")
# Force managed Python
Sys.setenv(RETICULATE_PYTHON = "managed")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
ffmpeg <- import("imageio_ffmpeg")
exe <- ffmpeg$get_ffmpeg_exe()
return(normalizePath(exe))
exe
library(flySurvivalApp)
Load_fly_app()
Load_fly_app()
library(flySurvivalApp)
Load_fly_app()
Load_fly_app()
install.packages("flySurvivalApp_0.0.0.9000.tar.gz", repos = NULL, type = "source")
library(flySurvivalApp)
Load_fly_app()
