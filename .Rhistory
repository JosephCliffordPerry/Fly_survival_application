expect_true(dir.exists(expected_folder))
# Check that log messages include success message
expect_true(any(grepl("Finished converting: test_video.AVI", log_messages)))
})
test_that("Avi_to_tiff finds ffmpeg path on Windows", {
# Mock Sys.info() to return Windows
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Windows"))
# Call Avi_to_tiff internals via a wrapper
ffmpeg_path <- local({
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
if (sysname == "Windows") {
return(file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
} else if (sysname == "Darwin") {
return(file.path("ffmpeg_mac", "ffmpeg"))
} else {
stop("Unsupported OS for bundled ffmpeg")
}
}
get_ffmpeg_path()
})
expect_equal(ffmpeg_path, file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
})
library(mockery)
install.packages("mockery")
# Mock Sys.info() to return Windows
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Windows"))
library(mockery)
# Mock Sys.info() to return Windows
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Windows"))
test_that("Avi_to_tiff finds ffmpeg path on Windows", {
# Mock Sys.info() to return Windows
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Windows"))
# Call Avi_to_tiff internals via a wrapper
ffmpeg_path <- local({
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
if (sysname == "Windows") {
return(file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
} else if (sysname == "Darwin") {
return(file.path("ffmpeg_mac", "ffmpeg"))
} else {
stop("Unsupported OS for bundled ffmpeg")
}
}
get_ffmpeg_path()
})
expect_equal(ffmpeg_path, file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
})
test_that("Avi_to_tiff finds ffmpeg path on macOS", {
# Mock Sys.info() to return Darwin
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Darwin"))
ffmpeg_path <- local({
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
if (sysname == "Windows") {
return(file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
} else if (sysname == "Darwin") {
return(file.path("ffmpeg_mac", "ffmpeg"))
} else {
stop("Unsupported OS for bundled ffmpeg")
}
}
get_ffmpeg_path()
})
expect_equal(ffmpeg_path, file.path("ffmpeg_mac", "ffmpeg"))
})
# Mock Sys.info() to return Darwin
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Darwin"))
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
if (sysname == "Windows") {
return(file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
} else if (sysname == "Darwin") {
return(file.path("ffmpeg_mac", "ffmpeg"))
} else {
stop("Unsupported OS for bundled ffmpeg")
}
}
get_ffmpeg_path()
test_that("Avi_to_tiff stops for unsupported OS", {
stub(Avi_to_tiff, "Sys.info", function() list(sysname = "Linux"))
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
if (sysname == "Windows") {
return(file.path("ffmpeg_windows", "bin", "ffmpeg.exe"))
} else if (sysname == "Darwin") {
return(file.path("ffmpeg_mac", "ffmpeg"))
} else {
stop("Unsupported OS for bundled ffmpeg")
}
}
expect_error(get_ffmpeg_path(), "Unsupported OS")
})
test_that("Avi_to_tiff handles empty folder gracefully", {
tmp <- local_tempdir()
log_messages <- character()
log_fun <- function(msg) log_messages <<- c(log_messages, msg)
# Should not error and should log "No AVI files found"
expect_silent(Avi_to_tiff(tmp, log_fun = log_fun))
expect_true(any(grepl("No AVI files found", log_messages)))
})
test_that("Avi_to_tiff handles empty folder gracefully", {
tmp <- local_tempdir()
log_messages <- character()
log_fun <- function(msg) log_messages <<- c(log_messages, msg)
# Should not error and should log "No AVI files found"
expect_silent(Avi_to_tiff(tmp, log_fun = log_fun))
expect_true(any(grepl("No AVI files found", log_messages)))
})
load_all()
Load_fly_app()
install.packages("flySurvivalApp")
install.packages("flySurvivalApp_0.0.0.9000.tar.gz", repos = NULL, type = "source")
library(flySurvivalApp)
Load_fly_app()
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
# --- Check bundled paths (if you ship your own ffmpeg) ---
if (sysname == "Windows") {
candidate <- file.path("ffmpeg_windows", "bin", "ffmpeg.exe")
} else if (sysname == "Darwin") {
candidate <- file.path("ffmpeg_mac", "ffmpeg")
} else {
candidate <- NULL
}
if (!is.null(candidate) && file.exists(candidate)) {
return(normalizePath(candidate))
}
# --- Check system ffmpeg ---
sys_ffmpeg <- Sys.which("ffmpeg")
if (nzchar(sys_ffmpeg)) {
return(normalizePath(sys_ffmpeg))
}
# --- Install via Python managed environment ---
message("FFmpeg not found. Using managed Python environment...")
# Force managed Python
Sys.setenv(RETICULATE_PYTHON = "managed")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
ffmpeg <- import("imageio_ffmpeg")
exe <- ffmpeg$get_ffmpeg_exe()
return(normalizePath(exe))
}
# --- Example usage ---
ffmpeg_path <- get_ffmpeg_path()
ffmpeg_path
get_ffmpeg_path <- function() {
sysname <- Sys.info()[["sysname"]]
# --- Check bundled paths (if you ship your own ffmpeg) ---
if (sysname == "Windows") {
candidate <- file.path("ffmpeg_windows", "bin", "ffmpeg.exe")
} else if (sysname == "Darwin") {
candidate <- file.path("ffmpeg_mac", "ffmpeg")
} else {
candidate <- NULL
}
if (!is.null(candidate) && file.exists(candidate)) {
return(normalizePath(candidate))
}
# --- Check system ffmpeg ---
sys_ffmpeg <- Sys.which("ffmpeg")
if (nzchar(sys_ffmpeg)) {
return(normalizePath(sys_ffmpeg))
}
# --- Install via Python managed environment ---
message("FFmpeg not found. Using managed Python environment...")
# Force managed Python
Sys.setenv(RETICULATE_PYTHON = "managed")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
ffmpeg <- import("imageio_ffmpeg")
exe <- ffmpeg$get_ffmpeg_exe()
return(normalizePath(exe))
}
# --- Example usage ---
ffmpeg_path <- get_ffmpeg_path()
# Force managed Python
Sys.setenv(RETICULATE_PYTHON = "managed")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
ffmpeg <- import("imageio_ffmpeg")
# Force managed Python
Sys.setenv(RETICULATE_PYTHON = "managed")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
ffmpeg <- import("imageio_ffmpeg")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
library(reticulate)
# --- Install via Python managed environment ---
message("FFmpeg not found. Using managed Python environment...")
# Force managed Python
Sys.setenv(RETICULATE_PYTHON = "managed")
# Ensure Python + required packages exist
reticulate::py_require(
packages = c("imageio-ffmpeg"),
python_version = "3.12.4" # lock Python version
)
ffmpeg <- import("imageio_ffmpeg")
exe <- ffmpeg$get_ffmpeg_exe()
return(normalizePath(exe))
exe
library(flySurvivalApp)
Load_fly_app()
Load_fly_app()
library(flySurvivalApp)
Load_fly_app()
Load_fly_app()
install.packages("flySurvivalApp_0.0.0.9000.tar.gz", repos = NULL, type = "source")
library(flySurvivalApp)
Load_fly_app()
install.packages("flySurvivalApp_0.0.0.9000.tar.gz", repos = NULL, type = "source")
install.packages("flySurvivalApp")
install.packages("flySurvivalApp")
install.packages("flySurvivalApp_0.0.0.9000.tar.gz", repos = NULL, type = "source")
# Install devtools if not already installed
install.packages("devtools")
# Load devtools
library(devtools)
# Install the package locally
install_local("C:/path/to/flySurvivalApp_0.0.0.9000.tar.gz")
# Install the package locally
install_local("flySurvivalApp_0.0.0.9000.tar.gz")
devtools::install_github("JosephCliffordPerry/flySurvivalApp", ref = "Package")
devtools::install_github("https://github.com/JosephCliffordPerry/Fly_survival_application.git", ref = "Package")
Load_fly_app()
devtools::load_all()
Load_fly_app()
inference_panel <- function() {
list(
ui = shiny::tabPanel(
"Inference",
shiny::fluidPage(
shiny::titlePanel("Run Multi-Model Inference"),
shiny::sidebarLayout(
shiny::sidebarPanel(
shinyFiles::shinyDirButton("image_dir", "Choose Image Subfolder", "Select a folder"),
shiny::textInput("stats_filename", "Output File Name (without extension):", "inference_results"),
shiny::numericInput("iou", "IoU Threshold:", 0.5, min = 0, max = 1, step = 0.05),
shiny::actionButton("run_inference", "Run Inference", class = "btn-success")
),
shiny::mainPanel(
shiny::h4("Logs"),
shiny::verbatimTextOutput("inference_log")
)
)
)
),
server = function(input, output, session) {
# Set default root to entire file system
roots <- c(Home = normalizePath("~"))
# Add avi_frames folder as a named shortcut
avi_path <- file.path(getwd(), "avi_frames")
if (dir.exists(avi_path)) {
roots <- c(avi_frames = normalizePath(avi_path), roots)
}
shinyFiles::shinyDirChoose(input, "image_dir", roots = roots, session = session)
output$inference_log <- shiny::renderText({
"Click 'Run Inference' to start. Progress will be shown above."
})
shiny::observeEvent(input$run_inference, {
shiny::req(input$image_dir)
image_dir <- shinyFiles::parseDirPath(roots, input$image_dir)
stats_dir <- file.path(getwd(), "statsdir")
# Ensure all filenames end with _raw.txt
base_name <- tools::file_path_sans_ext(input$stats_filename)
stats_file <- file.path(stats_dir, paste0(base_name, "_raw.txt"))
tryCatch({
run_inference_multi(
image_dir, stats_file,
iou_threshold = input$iou
)
output$inference_log <- shiny::renderText("Inference completed successfully!")
}, error = function(e) {
output$inference_log <- shiny::renderText(paste("Error:", e$message))
})
})
}
)
}
Load_fly_app()
Load_fly_app()
Load_fly_app()
library(flySurvivalApp)
Load_fly_app()
Load_fly_app()
library(flySurvivalApp)
Load_fly_app()
df <- utils::read.table("D:/Fly_survival_app/flySurvivalApp/statsdir/inference_results_raw.txt", stringsAsFactors = FALSE)
df <- utils::read.table(file, stringsAsFactors = FALSE,header = TRUE)
df <- utils::read.table("D:/Fly_survival_app/flySurvivalApp/statsdir/inference_results_raw.txt", stringsAsFactors = FALSE,header = TRUE)
Load_fly_app()
library(flySurvivalApp)
Load_fly_app()
Load_fly_app()
library(flySurvivalApp)
Load_fly_app()
library(flySurvivalApp)
library(flySurvivalApp)
Load_fly_app()
library(flySurvivalApp)
Load_fly_app()
Load_fly_app()
Load_fly_app()
library(testthat)
library(shiny)
library(sf)
test_that("browse_panel returns UI and server components", {
bp <- browse_panel(df_analysis = reactiveVal(), frame_paths = reactiveVal(c("f1.tif", "f2.tif")))
expect_type(bp, "list")
expect_named(bp, c("ui", "server"))
expect_true(inherits(bp$ui, "shiny.tag"))
expect_true(is.function(bp$server))
})
bp <- browse_panel(df_analysis = reactiveVal(), frame_paths = reactiveVal(c("f1.tif", "f2.tif")))
library(devtools)
load_all()
bp <- browse_panel(df_analysis = reactiveVal(), frame_paths = reactiveVal(c("f1.tif", "f2.tif")))
expect_type(bp, "list")
expect_named(bp, c("ui", "server"))
expect_true(inherits(bp$ui, "shiny.tag"))
expect_true(is.function(bp$server))
test_that("browse_panel returns UI and server components", {
bp <- browse_panel(df_analysis = reactiveVal(), frame_paths = reactiveVal(c("f1.tif", "f2.tif")))
expect_type(bp, "list")
expect_named(bp, c("ui", "server"))
expect_true(inherits(bp$ui, "shiny.tag"))
expect_true(is.function(bp$server))
})
test_that("UI contains key elements", {
bp <- browse_panel(df_analysis = reactiveVal(), frame_paths = reactiveVal())
ui <- bp$ui
expect_true(any(grepl("Browse Inferences", as.character(ui))))
expect_true(any(grepl("iou_threshold", as.character(ui))))
expect_true(any(grepl("run_analysis", as.character(ui))))
expect_true(any(grepl("frame_plot", as.character(ui))))
})
test_that("obb_iou correctly handles overlapping and non-overlapping boxes", {
bp <- browse_panel(df_analysis = reactiveVal(), frame_paths = reactiveVal())
srv <- environment(bp$server)$obb_iou
square1 <- matrix(c(0,0, 1,0, 1,1, 0,1), ncol=2, byrow=TRUE)
square2 <- matrix(c(0.5,0.5, 1.5,0.5, 1.5,1.5, 0.5,1.5), ncol=2, byrow=TRUE)
square3 <- matrix(c(2,2, 3,2, 3,3, 2,3), ncol=2, byrow=TRUE)
expect_gt(srv(square1, square2), 0)
expect_equal(srv(square1, square3), 0)
})
bp <- browse_panel(df_analysis = reactiveVal(), frame_paths = reactiveVal())
srv <- environment(bp$server)$obb_iou
square1 <- matrix(c(0,0, 1,0, 1,1, 0,1), ncol=2, byrow=TRUE)
square2 <- matrix(c(0.5,0.5, 1.5,0.5, 1.5,1.5, 0.5,1.5), ncol=2, byrow=TRUE)
square3 <- matrix(c(2,2, 3,2, 3,3, 2,3), ncol=2, byrow=TRUE)
expect_gt(srv(square1, square2), 0)
expect_equal(srv(square1, square3), 0)
srv <- environment(bp$server)$obb_iou
bp <- browse_panel(df_analysis = reactiveVal(), frame_paths = reactiveVal())
srv <- environment(bp$server)$obb_iou
test_that("obb_iou is available inside testServer and computes IoU", {
test_that("obb_iou is available inside testServer and computes IoU", {
# minimal valid df so server starts
df <- data.frame(
x1=0,y1=0, x2=1,y2=0, x3=1,y3=1, x4=0,y4=1,
frame="f_1.tif", frame_num=1, manual=FALSE,
stringsAsFactors = FALSE
)
bp <- browse_panel(df_analysis = reactiveVal(df),
frame_paths = reactiveVal(c("frame1.tif","frame2.tif")))
shiny::testServer(bp$server, {
# inside testServer the server body has executed -> obb_iou exists
srv <- get("obb_iou", envir = environment())   # <--- correct way here
sq1 <- matrix(c(0,0, 1,0, 1,1, 0,1), ncol=2, byrow=TRUE)
sq2 <- matrix(c(0.5,0.5, 1.5,0.5, 1.5,1.5, 0.5,1.5), ncol=2, byrow=TRUE)
expect_gt(srv(sq1, sq2), 0)
expect_equal(srv(sq1, sq1), 1, tolerance = 1e-6)
})
})
test_that("obb_iou returns 0 for invalid polygons", {
bp <- browse_panel(df_analysis = reactiveVal(), frame_paths = reactiveVal())
srv <- environment(bp$server)$obb_iou
bad1 <- matrix(c(0,0, 1,1, 0,0, 1,1), ncol=2, byrow=TRUE)
good <- matrix(c(0,0, 1,0, 1,1, 0,1), ncol=2, byrow=TRUE)
expect_equal(srv(bad1, good), 0)
})
test_that("obb_iou returns 0 for invalid polygons", {
bp <- browse_panel(df_analysis = reactiveVal(), frame_paths = reactiveVal(c("f1.tif")))
testServer(bp$server, {
obb_iou <- get("obb_iou", envir = environment())
bad1 <- matrix(c(0,0, 1,1, 0,0, 1,1), ncol = 2, byrow = TRUE)
good <- matrix(c(0,0, 1,0, 1,1, 0,1), ncol = 2, byrow = TRUE)
expect_equal(obb_iou(bad1, good), 0)
})
})
test_that("run_analysis stops on missing or invalid df_analysis", {
df_react <- reactiveVal(NULL)
frame_react <- reactiveVal(c("f1.tif"))
bp <- browse_panel(df_react, frame_react)
expect_error(
testServer(bp$server, {
session$setInputs(run_analysis = 1)
}),
regexp = "must be a non-empty data\\.frame"
)
})
test_that("run_analysis stops on missing frames", {
df_react <- reactiveVal(data.frame(
x1 = 1, y1 = 1, x2 = 2, y2 = 1, x3 = 2, y3 = 2, x4 = 1, y4 = 2, frame = "f1.tif"
))
frame_react <- reactiveVal(NULL)
bp <- browse_panel(df_react, frame_react)
expect_error(
testServer(bp$server, {
session$setInputs(run_analysis = 1)
}),
regexp = "no frames available"
)
})
test_that("run_analysis stops on missing columns", {
df_react <- reactiveVal(data.frame(x1 = 1, y1 = 1, frame = "f1.tif"))
frame_react <- reactiveVal(c("f1.tif"))
bp <- browse_panel(df_react, frame_react)
expect_error(
testServer(bp$server, {
session$setInputs(run_analysis = 1)
}),
regexp = "missing required columns"
)
})
test_that("save_path generates unique paths", {
df_react <- reactiveVal(data.frame(
x1 = 1, y1 = 1, x2 = 2, y2 = 1, x3 = 2, y3 = 2, x4 = 1, y4 = 2, frame = "f1.tif"
))
frame_react <- reactiveVal(c("frames/f1.tif"))
bp <- browse_panel(df_react, frame_react)
testServer(bp$server, {
path <- save_path()
expect_true(grepl("processed", path))
expect_true(grepl("statsdir", path))
})
})
df_react <- reactiveVal(data.frame(x1 = 1, y1 = 1, frame = "f1.tif"))
frame_react <- reactiveVal(c("f1.tif"))
bp <- browse_panel(df_react, frame_react)
expect_error(
testServer(bp$server, {
session$setInputs(run_analysis = 1)
}),
regexp = "missing required columns"
)
test_that("save_path generates unique paths", {
df_react <- reactiveVal(data.frame(
x1 = 1, y1 = 1, x2 = 2, y2 = 1, x3 = 2, y3 = 2, x4 = 1, y4 = 2, frame = "f1.tif"
))
frame_react <- reactiveVal(c("frames/f1.tif"))
bp <- browse_panel(df_react, frame_react)
testServer(bp$server, {
path <- save_path()
expect_true(grepl("processed", path))
expect_true(grepl("statsdir", path))
})
})
test_that("run_analysis stops on missing frames", {
df_react <- reactiveVal(data.frame(
x1 = 1, y1 = 1, x2 = 2, y2 = 1, x3 = 2, y3 = 2, x4 = 1, y4 = 2, frame = "f1.tif"
))
frame_react <- reactiveVal(NULL)
bp <- browse_panel(df_react, frame_react)
expect_error(
testServer(bp$server, {
session$setInputs(run_analysis = 1)
}),
regexp = "no frames available"
)
})
test_that("run_analysis stops on missing or invalid df_analysis", {
df_react <- reactiveVal(NULL)
frame_react <- reactiveVal(c("f1.tif"))
bp <- browse_panel(df_react, frame_react)
expect_error(
testServer(bp$server, {
session$setInputs(run_analysis = 1)
}),
regexp = "must be a non-empty data\\.frame"
)
})
test_that("obb_iou returns 0 for invalid polygons", {
bp <- browse_panel(df_analysis = reactiveVal(), frame_paths = reactiveVal(c("f1.tif")))
testServer(bp$server, {
obb_iou <- get("obb_iou", envir = environment())
bad1 <- matrix(c(0,0, 1,1, 0,0, 1,1), ncol = 2, byrow = TRUE)
good <- matrix(c(0,0, 1,0, 1,1, 0,1), ncol = 2, byrow = TRUE)
expect_equal(obb_iou(bad1, good), 0)
})
})
tmp <- local_tempdir()
log_messages <- character()
log_fun <- function(msg) log_messages <<- c(log_messages, msg)
tmp <- local_tempdir()
